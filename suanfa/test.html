<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no,viewport-fit=cover">
  <title>Lazyload</title>
  <style></style>
</head>

<body>
  <div id="div"></div>
  <!-- <script src="./face/js功能Demo/reactHooks.js"></script> -->
  <!-- <script src="./likou/easy/第K大元素.js"></script> -->
  <script>

// const arr = [1, 2, 3].map((number, index) => ({
//   [index]: number,
// }));
// console.log(arr)

// console.log(9>>>2) // 0000 1001-》 0000 0010   2

    // console.log(Number(5).toString(2))
// console.log(0)
// setTimeout(()=> {
//   console.log("timer1");
//   Promise.resolve().then(()=> {
//     console.log("promise1")
//   })
// });
// setTimeout(()=> {
//   console.log("timer2");
//   Promise.resolve().then(()=> {
//     console.log("promise2")
//   })
// })
// 0 timer1 promise1 timer2 promsie2 

// const worker = new Worker('./face/js功能Demo/webworker.js')
// const uInt8Array = new Uint8Array(new ArrayBuffer(10));
// for (let i = 0; i < uInt8Array.length; i++) {
//   uInt8Array[i] = i * 2;
// }
// console.log(uInt8Array)
// worker.postMessage(uInt8Array);
    // clientHeight scrollTop offsetTop offsetHeight getBoundClientReac()
    // touchstart touchmove touchend touches targetThouches clientX clientY pageX pageY


  // Array.prototype.meForEach = function (fn) {
  //   if (typeof fn !=="function") {
  //     throw new TypeError(fn + "is not a funciton")
  //   }
  //   for (let i = 0; i < this.length; i++) {
  //     fn.call(this, this[i], i, this);
  //   }
  // }



    // 节流 一段时间内只执行一次
    // function trot(func, wait) {
    //   let timeout;
    //   return function () {
    //     if (!timeout) {
    //       timeout = setTimeout(()=> {
    //         timeout = null;
    //         func.apply(this, arguments);
    //       }, wait);
    //     }
    //   }
    // }

    // // new
    // function newObj() {
    //   let obj = Object.create(null); 
    //   let ctr = [].shift.call(arguments);
    //   obj.__proto = ctr.prototype;
    //   let ret = ctr.apply(obj, arguments);
    //   return ret instanceof Object ? ret : obj;
    // }

    // // bind
    // Function.prototype.bind = function (context) {
    //   let self = this;
    //   return function() {
    //     return self.apply(context)
    //   }
    // }

    // // bind
    // Function.prototype.bind = function(context) {
    //   let self = this;
    //   let args = Array.prototype.slice.call(argument, 1)
    //   return function () {
    //     let bindArgs = args.concat(Array.prototype.slice.call(arguments));
    //     return self.apply(context, bindArgs)
    //   }
    // }

    // // call
    // Function.prototype.call2 = function (context) {
    //   context.fn = this;
    //   let args = [].slice.call(arguments, 1);
    //   context.fn(args);
    //   delete context.fn;
    // }

    // // call
    // Function.prototype.call3 = function (context) {
    //   context = context || window;
    //   context.fn = this;
    //   let args = [].slice.call(arguments, 1);
    //   console.log(args)
    //   let result = context.fn(...args); // 
    //   // let result = eval('context.fn('+arg+')')
    //   delete context.fn;
    //   return result;
    // }

    // // var foo = {
    // //     value: 1
    // // };

    // // function bar(name, age) {
    // //     console.log(name)
    // //     console.log(age)
    // //     console.log(this.value);
    // // }
    // // bar.call3(foo, 'kevin', 18);

    // let event = {
    //   arr: [],
    //   result: [],
    //   on(fn) {
    //     this.arr.push(fn);
    //   },
    //   emit(data) {
    //     this.result.push(data);
    //     if (this.result.length === 2) {
    //       this.arr.forEach(fn=> {
    //         return fn(this.result);
    //       })
    //     }
    //   }
    // }

    // event.on(function (data) {
    //   if (data.length === 2) {
    //     console.log(data)
    //   }
    // })

    // event.emit(1)
    // event.emit(2)


    // Promise.all = function (promises) {
    //   if (!Array.isArray(promises)) {
    //     return new Error('arguments must be an array');
    //   }
    //   return new Promise((resolve, reject)=> {
    //     let arr = [];
    //     let length = promises.length;
    //     function postData(index, data) {
    //       arr[index] = data;
    //       if (arr.length === length) {
    //         resolve(data);
    //       }
    //     }
    //     for (let i = 0; i < length; i++) {
    //       Promise.then((value)=> {
    //         postData(i, value)
    //       }, (reson)=> {
    //         return reject(reson)
    //       });
    //     }
    //   })
    // }

    // function thro(func, wait) {
    //   let timeout;
    //   return function () {
    //     if (!timeout) {
    //       timeout = setTimeout(()=> {
    //         timeout = null;
    //         func.apply(this, arguments)
    //       }, wait)
    //     }
    //   }
    // }

    // // function compose(arr) {
    // //   return function () {
    // //     arr.reduce((fn, cur)=> {
    // //       return fn(cur())
    // //     }, arr[0](arguments))
    // //   }
    // // }

    //   function compose(arr) {
    //     let length = arr.length;
    //     let count = length - 1;
    //     let result;
    //     return function f1() {
    //       result = arr[count].apply(this, arguments);
    //       if (count === 0) {
    //         return result;
    //       }
    //       count--;
    //       return f1.apply(null, result);
    //     }
    //   }

    //   function compose(arr) {
    //     let pipe = (...args)=>(f, g)=>g.call(null, f.apply(null, args));
    //     return arr.reserve().reduce(pipe, arr.shift())
    //   }


    // 根据数组形成二叉树
    // let list = [];
    // function createTree(list, start) {
    //   let root = new node(list[start]);
    //   let lnode = 2*start + 1;
    //   let rnode = 2*start + 2;
    //   if (lnode > list.length -1) {
    //     root.left = null;
    //   } else {
    //     createTree(list, lnode);
    //   }
    //   if (rnode > list.length -1) {
    //     root.right = null; 
    //   } else {
    //     createTree(list, rnode)
    //   }
    //   return root;
    // }
    // let root = createTree(list, 0) 

    // function deepCopy(obj) {
    //   if (typeof obj !== 'object') {
    //     return new Error('....')
    //   }
    //   let newObj = Array.isArray(obj) ? [] : {};;
    //   for (let i in obj) {
    //     if (obj.hasOwnPrototy(i)) {
    //       newObj = typeof obj[i] ==='object' ? deepCopy(obj[i]) : obj[i];
    //     }
    //   }
    // }

    // let xhr = new XMLHttpRequest()
    // console.log(xhr)

    // call
    // Function.prototype.call2 = function (context) {
    //   context.fn = this || window; 
    //   var args = [];
    //   for (var i = 1; i < arguments.length; i++) {
    //     args.push('arguments[' + i + ']');
    //   }
    //   console.log(args)
    //   var result = eval('context.fn('+ args+ ')');
    //   delete context.fn;
    //   return result;
    // }
    // // bind
    // Function.prototype.apply = function (context, arr) {
    //   context.fn = this || window;
    //   var result;
    //   if (!arr) {
    //     result = context.fn();
    //   } else {
    //     var args = [];
    //     for (var i = 0; i < arr.length; i++) {
    //       args.push('arr['+ i+ ']');
    //     }
    //     result = eval('context.fn('+args+')');
    //   }
    //   delete context.fn;
    //   return result;
    // }

    // Function.prototype.bind2 = function (context) {
    //   var self = this;
    //   var args = Array.prototype.slice.call(arguments, 1);
    //   return function () {
    //     self.apply(context, args.concat(Array.prototype.slice.call(arguments)));
    //   }
    // }
    // var foo = {
    //   value: 1
    // };
    // Function.prototype.bindMe = function (context) {
    //   var self = this;
    //   var args = Array.prototype.slice.call(arguments, 1);
    //   var func = function () {
    //     var bindArgs = Array.prototype.slice.call(arguments);
    //     // 当作为构造函数时，this 指向实例，self 指向绑定函数，因为下面一句 `fbound.prototype = this.prototype;`，已经修改了 fbound.prototype 为 绑定函数的 prototype，此时结果为 true，当结果为 true 的时候，this 指向实例。
    //     // 当作为普通函数时，this 指向 window，self 指向绑定函数，此时结果为 false，当结果为 false 的时候，this 指向绑定的 context。
    //     self.apply(this instanceof self ? this : context, args.concat(bindArgs))
    //   }
    //   func.prototype = self.prototype; // // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承函数的原型中的值；从而使得this instanceof self成立；
    //   return func;
    // }

    // function deepCopy(obj) {
    //   if(typeof obj !== "object") {
    //     return false;
    //   }
    //   var newObj = obj instanceof Array ? [] : {};
    //   for (var i in obj) {
    //     if (newObj.hasOwnProperty(i)) {
    //       newObj[i] = typeof obj[i] === 'Object' ? deepCopy(obj[i]) : obj[i] = i;
    //     }
    //   }
    //   return newObj;
    // }

    // function bar(name, age) {
    //   console.log(name)
    //   console.log(age)
    //   console.log(this.value);
    // }
    // let result = bar.call2(foo, 'zhouzhou', 28);

    // function Animal(){
    // 　this.species = "动物";
    // }
    // function Cat(name,color){
    //     Animal.apply(this, arguments);
    // 　　this.name = name;
    // 　　this.color = color;
    // }
    // Cat.prototype = new Animal();
    // alert(Cat.prototype.constructor == Animal); //true
    // Cat.prototype.constructor = Cat;
    // alert(Cat.prototype.constructor == Animal); //true

    // function replacer(match, p1, p2, p3, offset, string) {
    //   // p1 is nondigits, p2 digits, and p3 non-alphanumerics
    //   console.log(p1)
    //   console.log(match)
    //   console.log(offset)
    //   return [p1, p2, p3].join(' - ');
    // }
    // var newString = '12345 #$*% bc12345#$*%'.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);
    // console.log(newString);  // abc - 12345 - #$*%
    // var cat1 = new Cat("大毛","黄色");
    // alert(cat1.species); // 动物

//     var longestPalindrome1 = function (s) {
//       // babad
//       // tag : dp
//       if (!s || s.length === 0) return "";
//       let res = s[0];

//       const dp = [];

//       // 倒着遍历简化操作， 这么做的原因是dp[i][..]依赖于dp[i + 1][..]
//       for (let i = s.length - 1; i >= 0; i--) {
//         dp[i] = [];
//         for (let j = i; j < s.length; j++) {
//           if (j - i === 0) dp[i][j] = true;
//           // specail case 1
//           else if (j - i === 1 && s[i] === s[j]) dp[i][j] = true;
//           // specail case 2
//           else if (s[i] === s[j] && dp[i + 1][j - 1]) {
//             // state transition
//             dp[i][j] = true;
//           }
//           if (dp[i][j] && j - i + 1 > res.length) {
//             // update res
//             res = s.slice(i, j + 1);
//           }
//         }
//       }

//       return res;
//     };
//     /**
//  * @param {string} s
//  * @return {string}
//  */
//     var longestPalindrome2 = function (s) {
//       let n = s.length;
//       let res = '';
//       let dp = Array.from(new Array(n), () => new Array(n).fill(0));
//       // console.log(dp)
//       for (let i = n - 1; i >= 0; i--) {
//         for (let j = i; j < n; j++) {
//           dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);
//           console.log(i);
//           console.log(j)
//           console.log(dp[i][j])

//           if (dp[i][j] && j - i + 1 > res.length) {
//             console.log(i);
//             console.log(j)
//             res = s.substring(i, j + 1);
//           }
//           console.log(res)
//           console.log("-----")
//         }
//       }
//       console.log(dp)
//       return res;
//     };

//     function longestPalindrome5(s) { // 中心扩散 很多重复的，所以使用动态规划， 说白了就是空间换时间，将计算结果暂存起来，避免重复计算。作用和工程中用 redis 做缓存有异曲同工之妙。
//       if (s == null || s.length == 0) {
//         return "";
//       }
//       let strLen = s.length();
//       let left = 0;
//       let right = 0;
//       let len = 1;
//       let maxStart = 0;
//       let maxLen = 0;

//       for (let i = 0; i < strLen; i++) {
//         left = i - 1;
//         right = i + 1;
//         while (left >= 0 && s.charAt(left) == s.charAt(i)) {
//           len++;
//           left--;
//         }
//         while (right < strLen && s.charAt(right) == s.charAt(i)) {
//           len++;
//           right++;
//         }
//         while (left >= 0 && right < strLen && s.charAt(right) == s.charAt(left)) {
//           len = len + 2;
//           left--;
//           right++;
//         }
//         if (len > maxLen) {
//           maxLen = len;
//           maxStart = left;
//         }
//         len = 1;
//       }
//       return s.substring(maxStart + 1, maxStart + maxLen + 1);

//     }

//     /**
//      * @param {string} s
//      * @return {string}
//      */
//     var longestPalindrome = function (s) {
//       let n = s.length;
//       let dp = Array.from(new Array(n), () => new Array(n).fill(0)); // 初始化二维数组用于记录dp[i][j]是否为true
//       let res = "";
//       for (let i = n - 1; i >= 0; i--) { // 从字符串的末尾开始构建dp[i][j]
//         for (let j = i; j < n; j++) {
//           dp[i][j] = s[i] == s[j] && (j - i < 2 || dp[i + 1][j - 1]);
//           if (dp[i][j] && j - i + 1 > res.length) {
//             res = s.substring(i, j + 1);
//           }
//         }
//       }
//       return res;
//     }


//     const result = longestPalindrome("aba")
//     console.log(result)



// function b(arr) {
//   for (let i = 0; i < arr.length; i++) {
//     for (let j = 0; j < arr.length -i; i++) {
//       let temp;
//       if (arr[i] > arr[j]) {
//         temp = arr[i];
//         arr[i] = arr[j];
//         arr[j] = temp;
//       }
//     }
//   }
//   return arr;
// }


window.onload = function () {
  var adiv = document.getElementById("div");
  var root = adiv.webkitCreateShadowRoot();
  var shadowImag = document.createElement("img");
  shadowImag.src = 'apic.png';
  root.appdendChild(shadowImag);
  var shadowDiv = document.createElement("div");
  shadowDiv.innerHTML = "this is a div from shadow dom";
  root.appdendChild(shadowDiv)
}
  </script>
</body>

</html>